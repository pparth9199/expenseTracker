{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=createAnimatedComponent;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _assertThisInitialized2=_interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _react=_interopRequireDefault(require(\"react\"));var _reactNative=require(\"react-native\");var _ReanimatedEventEmitter=_interopRequireDefault(require(\"./ReanimatedEventEmitter\"));var _AnimatedEvent=_interopRequireDefault(require(\"./core/AnimatedEvent\"));var _AnimatedNode=_interopRequireDefault(require(\"./core/AnimatedNode\"));var _AnimatedValue=_interopRequireDefault(require(\"./core/AnimatedValue\"));var _AnimatedProps=require(\"./core/AnimatedProps\");var _invariant=_interopRequireDefault(require(\"fbjs/lib/invariant\"));function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var NODE_MAPPING=new Map();function listener(data){var component=NODE_MAPPING.get(data.viewTag);component&&component._updateFromNative(data.props);}function dummyListener(){}function createAnimatedComponent(Component){(0,_invariant.default)(typeof Component!=='function'||Component.prototype&&Component.prototype.isReactComponent,'`createAnimatedComponent` does not support stateless functional components; '+'use a class component instead.');var AnimatedComponent=function(_React$Component){(0,_inherits2.default)(AnimatedComponent,_React$Component);var _super=_createSuper(AnimatedComponent);function AnimatedComponent(props){var _this;(0,_classCallCheck2.default)(this,AnimatedComponent);_this=_super.call(this,props);_defineProperty((0,_assertThisInitialized2.default)(_this),\"_invokeAnimatedPropsCallbackOnMount\",false);_defineProperty((0,_assertThisInitialized2.default)(_this),\"_animatedPropsCallback\",function(){if(_this._component==null){_this._invokeAnimatedPropsCallbackOnMount=true;}else if(typeof _this._component.setNativeProps!=='function'){_this.forceUpdate();}else{_this._component.setNativeProps(_this._propsAnimated.__getValue());}});_defineProperty((0,_assertThisInitialized2.default)(_this),\"_setComponentRef\",function(c){if(c!==_this._component){_this._component=c;}});_this._attachProps(_this.props);return _this;}(0,_createClass2.default)(AnimatedComponent,[{key:\"componentWillUnmount\",value:function componentWillUnmount(){this._detachPropUpdater();this._propsAnimated&&this._propsAnimated.__detach();this._detachNativeEvents();}},{key:\"setNativeProps\",value:function setNativeProps(props){this._component.setNativeProps(props);}},{key:\"componentDidMount\",value:function componentDidMount(){if(this._invokeAnimatedPropsCallbackOnMount){this._invokeAnimatedPropsCallbackOnMount=false;this._animatedPropsCallback();}this._propsAnimated.setNativeView(this._component);this._attachNativeEvents();this._attachPropUpdater();}},{key:\"_getEventViewRef\",value:function _getEventViewRef(){return this._component.getScrollableNode?this._component.getScrollableNode():this._component;}},{key:\"_attachNativeEvents\",value:function _attachNativeEvents(){var node=this._getEventViewRef();for(var key in this.props){var prop=this.props[key];if(prop instanceof _AnimatedEvent.default){prop.attachEvent(node,key);}}}},{key:\"_detachNativeEvents\",value:function _detachNativeEvents(){var node=this._getEventViewRef();for(var key in this.props){var prop=this.props[key];if(prop instanceof _AnimatedEvent.default){prop.detachEvent(node,key);}}}},{key:\"_reattachNativeEvents\",value:function _reattachNativeEvents(prevProps){var node=this._getEventViewRef();var attached=new Set();var nextEvts=new Set();for(var key in this.props){var prop=this.props[key];if(prop instanceof _AnimatedEvent.default){nextEvts.add(prop.__nodeID);}}for(var _key in prevProps){var _prop=this.props[_key];if(_prop instanceof _AnimatedEvent.default){if(!nextEvts.has(_prop.__nodeID)){_prop.detachEvent(node,_key);}else{attached.add(_prop.__nodeID);}}}for(var _key2 in this.props){var _prop2=this.props[_key2];if(_prop2 instanceof _AnimatedEvent.default&&!attached.has(_prop2.__nodeID)){_prop2.attachEvent(node,_key2);}}}},{key:\"_attachProps\",value:function _attachProps(nextProps){var oldPropsAnimated=this._propsAnimated;this._propsAnimated=(0,_AnimatedProps.createOrReusePropsNode)(nextProps,this._animatedPropsCallback,oldPropsAnimated);if(oldPropsAnimated!==this._propsAnimated){oldPropsAnimated&&oldPropsAnimated.__detach();}}},{key:\"_updateFromNative\",value:function _updateFromNative(props){this._component.setNativeProps(props);}},{key:\"_attachPropUpdater\",value:function _attachPropUpdater(){var viewTag=(0,_reactNative.findNodeHandle)(this);NODE_MAPPING.set(viewTag,this);if(NODE_MAPPING.size===1){_ReanimatedEventEmitter.default.addListener('onReanimatedPropsChange',listener);}}},{key:\"_detachPropUpdater\",value:function _detachPropUpdater(){var viewTag=(0,_reactNative.findNodeHandle)(this);NODE_MAPPING.delete(viewTag);if(NODE_MAPPING.size===0){_ReanimatedEventEmitter.default.removeAllListeners('onReanimatedPropsChange');}}},{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps){this._attachProps(this.props);this._reattachNativeEvents(prevProps);this._propsAnimated.setNativeView(this._component);}},{key:\"_filterNonAnimatedStyle\",value:function _filterNonAnimatedStyle(inputStyle){var style={};for(var key in inputStyle){var value=inputStyle[key];if(key!=='transform'){if(value instanceof _AnimatedValue.default){style[key]=value._startingValue;}else if(!(value instanceof _AnimatedNode.default)){style[key]=value;}}}return style;}},{key:\"_filterNonAnimatedProps\",value:function _filterNonAnimatedProps(inputProps){var props={};for(var key in inputProps){var value=inputProps[key];if(key==='style'){props[key]=this._filterNonAnimatedStyle(_reactNative.StyleSheet.flatten(value));}else if(value instanceof _AnimatedEvent.default){props[key]=dummyListener;}else if(value instanceof _AnimatedValue.default){props[key]=value._startingValue;}else if(!(value instanceof _AnimatedNode.default)){props[key]=value;}}return props;}},{key:\"render\",value:function render(){var props=this._filterNonAnimatedProps(this.props);var platformProps=_reactNative.Platform.select({web:{},default:{collapsable:false}});return _react.default.createElement(Component,_extends({},props,{ref:this._setComponentRef},platformProps));}},{key:\"getNode\",value:function getNode(){return this._component;}}]);return AnimatedComponent;}(_react.default.Component);AnimatedComponent.displayName=\"AnimatedComponent(\".concat(Component.displayName||Component.name||'Component',\")\");return AnimatedComponent;}","map":{"version":3,"sources":["createAnimatedComponent.js"],"names":["NODE_MAPPING","component","data","invariant","Component","React","constructor","node","prop","attached","nextEvts","oldPropsAnimated","createOrReusePropsNode","viewTag","findNodeHandle","ReanimatedEventEmitter","c","style","value","inputStyle","key","props","inputProps","StyleSheet","platformProps","web","default","collapsable","_setComponentRef","AnimatedComponent"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (key !== 'transform') {\n          if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          } else if (!(value instanceof AnimatedNode)) {\n            style[key] = value;\n          }\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof AnimatedValue) {\n          props[key] = value._startingValue;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return AnimatedComponent;\n}\n"]},"metadata":{},"sourceType":"script"}