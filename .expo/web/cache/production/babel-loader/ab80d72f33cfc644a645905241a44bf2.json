{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.createOrReuseTransformNode=createOrReuseTransformNode;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _AnimatedNode2=_interopRequireDefault(require(\"./AnimatedNode\"));var _areEqual=_interopRequireDefault(require(\"fbjs/lib/areEqual\"));function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function sanitizeTransform(inputTransform){var outputTransform=[];inputTransform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof _AnimatedNode2.default){outputTransform.push({property:key,nodeID:value.__nodeID});}else{outputTransform.push({property:key,value:value});}}});return outputTransform;}function extractAnimatedParentNodes(transform){var parents=[];transform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof _AnimatedNode2.default){parents.push(value);}}});return parents;}function createOrReuseTransformNode(transform,oldNode){var config=sanitizeTransform(transform);if(oldNode&&(0,_areEqual.default)(config,oldNode._config)){return oldNode;}return new AnimatedTransform(transform,config);}var AnimatedTransform=function(_AnimatedNode){(0,_inherits2.default)(AnimatedTransform,_AnimatedNode);var _super=_createSuper(AnimatedTransform);function AnimatedTransform(transform,config){var _this;(0,_classCallCheck2.default)(this,AnimatedTransform);_this=_super.call(this,{type:'transform',transform:config},extractAnimatedParentNodes(transform));_this._config=config;_this._transform=transform;return _this;}(0,_createClass2.default)(AnimatedTransform,[{key:\"toString\",value:function toString(){return\"AnimatedTransform, id: \".concat(this.__nodeID);}},{key:\"__onEvaluate\",value:function __onEvaluate(){return this._transform.map(function(transform){var result={};for(var key in transform){var value=transform[key];if(value instanceof _AnimatedNode2.default){result[key]=value.__getValue();}}return result;});}}]);return AnimatedTransform;}(_AnimatedNode2.default);","map":{"version":3,"sources":["AnimatedTransform.js"],"names":["outputTransform","inputTransform","transform","value","property","nodeID","__nodeID","parents","config","sanitizeTransform","oldNode","deepEqual","constructor","type","extractAnimatedParentNodes","result"],"mappings":"oqBAAA,qEAEA,mE,mtBAEA,QAAA,CAAA,iBAAA,CAAA,cAAA,CAA2C,CACzC,GAAMA,CAAAA,eAAe,CAArB,EAAA,CACAC,cAAc,CAAdA,OAAAA,CAAuBC,SAAAA,SAAS,CAAI,CAClC,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMC,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,uBAAA,CAAmC,CACjCH,eAAe,CAAfA,IAAAA,CAAqB,CACnBI,QAAQ,CADW,GAAA,CAEnBC,MAAM,CAAEF,KAAK,CAACG,QAFK,CAArBN,EADF,CAAA,IAKO,CACLA,eAAe,CAAfA,IAAAA,CAAqB,CACnBI,QAAQ,CADW,GAAA,CAEnBD,KAAAA,CAAAA,KAFmB,CAArBH,EAID,CACF,CAdHC,CAAAA,EAgBA,MAAA,CAAA,eAAA,CACD,CAED,QAAA,CAAA,0BAAA,CAAA,SAAA,CAA+C,CAC7C,GAAMM,CAAAA,OAAO,CAAb,EAAA,CACAL,SAAS,CAATA,OAAAA,CAAkBA,SAAAA,SAAS,CAAI,CAC7B,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMC,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,uBAAA,CAAmC,CACjCI,OAAO,CAAPA,IAAAA,CAAAA,KAAAA,EACD,CACF,CANHL,CAAAA,EAQA,MAAA,CAAA,OAAA,CACD,CAEM,QAAA,CAAA,0BAAA,CAAA,SAAA,CAAA,OAAA,CAAwD,CAC7D,GAAMM,CAAAA,MAAM,CAAGC,iBAAiB,CAAhC,SAAgC,CAAhC,CACA,GAAIC,OAAO,EAAIC,sBAAS,MAATA,CAAkBD,OAAO,CAAxC,OAAeC,CAAf,CAAmD,CACjD,MAAA,CAAA,OAAA,CACD,CACD,MAAO,IAAA,CAAA,iBAAA,CAAA,SAAA,CAAP,MAAO,CAAP,CACD,C,GAED,CAAA,iB,4HACEC,2BAAW,SAAXA,CAAW,MAAXA,CAA+B,gEAC7B,uBACE,CAAEC,IAAI,CAAN,WAAA,CAAqBX,SAAS,CAAEM,MAAhC,CADF,CAEEM,0BAA0B,CAF5B,SAE4B,CAF5B,EAIA,MAAA,OAAA,CAAA,MAAA,CACA,MAAA,UAAA,CAAA,SAAA,CAN6B,aAO9B,C,sFAEU,CACT,MAAA,0BAAA,MAAA,CAAiC,KAAjC,QAAA,CAAA,CACD,C,mDAEc,CACb,MAAO,MAAA,UAAA,CAAA,GAAA,CAAoBZ,SAAAA,SAAS,CAAI,CACtC,GAAMa,CAAAA,MAAM,CAAZ,EAAA,CACA,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMZ,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,uBAAA,CAAmC,CACjCY,MAAM,CAANA,GAAM,CAANA,CAAcZ,KAAK,CAAnBY,UAAcZ,EAAdY,CACD,CACF,CACD,MAAA,CAAA,MAAA,CARF,CAAO,CAAP,CAUD,C,+BAzBH,sB","sourcesContent":["import AnimatedNode from './AnimatedNode';\n\nimport deepEqual from 'fbjs/lib/areEqual';\n\nfunction sanitizeTransform(inputTransform) {\n  const outputTransform = [];\n  inputTransform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        outputTransform.push({\n          property: key,\n          nodeID: value.__nodeID,\n        });\n      } else {\n        outputTransform.push({\n          property: key,\n          value,\n        });\n      }\n    }\n  });\n  return outputTransform;\n}\n\nfunction extractAnimatedParentNodes(transform) {\n  const parents = [];\n  transform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        parents.push(value);\n      }\n    }\n  });\n  return parents;\n}\n\nexport function createOrReuseTransformNode(transform, oldNode) {\n  const config = sanitizeTransform(transform);\n  if (oldNode && deepEqual(config, oldNode._config)) {\n    return oldNode;\n  }\n  return new AnimatedTransform(transform, config);\n}\n\nclass AnimatedTransform extends AnimatedNode {\n  constructor(transform, config) {\n    super(\n      { type: 'transform', transform: config },\n      extractAnimatedParentNodes(transform)\n    );\n    this._config = config;\n    this._transform = transform;\n  }\n\n  toString() {\n    return `AnimatedTransform, id: ${this.__nodeID}`;\n  }\n\n  __onEvaluate() {\n    return this._transform.map(transform => {\n      const result = {};\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          result[key] = value.__getValue();\n        }\n      }\n      return result;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}